Задание 1. Сколько раз встречается максимум

На стандартном потоке ввода задается натуральное число N (N > 0), 
после которого следует последовательность из N целых чисел.
На стандартный поток вывода напечатайте, сколько раз в этой 
последовательности встречается максимум.

Указание: использовать массивы запрещается.

Данные на входе: Натуральное число N (N > 0), после которого следует
последовательность из N целых чисел.
Данные на выходе: Одно целое число.

Пример №1
Данные на входе: 6 1 2 3 2 0 3
Данные на выходе: 2

#include &lt;stdio.h&gt;
int main() {
int N, num, max_num, count_max_num;

// Вводим количество элементов в последовательности
printf("Введите количество элементов в последовательности: ");
scanf("%d", &N);

if (N > 0) {
// Считываем первое число и инициализируем переменные
scanf("%d", &max_num);
count_max_num = 1;

for (int i = 1; i < N; i++) {
// Считываем следующее число
scanf("%d", &num);

// Проверяем условие для определения максимального числа и его количества
if (num > max_num) {
max_num = num;
count_max_num = 1;
} else if (num == max_num) {
count_max_num++;
}
}

// Выводим количество вхождений максимального числа
printf("Количество вхождений максимального числа: %d\n", count_max_num);
}

return 0;
}


Задание 2. Инверсия старших

На вход программе подается беззнаковое 32-битное целое число N. 
Требуется изменить значения всех битов старшего байта числа на 
противоположные и вывести полученное таким образом число.

Данные на входе: Беззнаковое 32-битное целое число N
Данные на выходе: Одно целое число.

Пример №1
Данные на входе: 1
Данные на выходе: 4278190081


#include <stdio.h>

int main() {
    unsigned int N;
    
    // Вводим число N
    printf("Введите 32-битное целое число: ");
    scanf("%u", &N);
    
    // Получаем маску для старшего байта (байта с индексами от 24 до 31) 
    unsigned int mask = 0xFF000000;
    
    // Инвертируем биты старшего байта через операцию XOR
    unsigned int result = N ^ mask;
    
    // Выводим полученное число
    printf("Полученное число после инвертирования битов старшего байта: %u\n", result);
    
    return 0;
}


Задание 3. Не пара

Преподаватели Geek Brains создали набор, содержащий N (1 ≤ N ≤ 1 000 000) натуральных чисел, 
не превосходящих 1 000 000. Известно, что ровно одно число в этом наборе встречается один раз, 
а остальные — ровно по два раза. Помогите им найти это число. Входные данные: 
в первой входной строке вводится число N, затем по одному числу в строке вводятся N натуральных чисел, 
не превосходящих 2 000 000 000. Выходные данные: ваша программа должна определить число, встречающееся один раз, 
и вывести его на экран.

Указание: использовать массивы запрещается.

Данные на входе: Натуральное число N (N > 0), после которого следует
последовательность из N целых чисел.
Данные на выходе: Одно целое число.

Пример №1
Данные на входе: 3 12 15 12
Данные на выходе: 15

#include <stdio.h>

int main() {
    int N, num, unique_num = 0;

    printf ("Введите число элементов последовательности: ");
    scanf("%d", &N);

    // Применяем операцию XOR ко всем элементам последовательности
    for (int i = 0; i < N; i++) {
        scanf("%d", &num);
        unique_num ^= num;
    }

    // Выводим уникальное число
    printf("%d\n", unique_num);

    return 0;
}


#include <stdio.h>

int main() {
    int N;
    char symbol;

    printf ("Введите фразу для шифра: ");
    scanf("%d", &N);

    // Считываем символы и кодируем их шифром Цезаря
    while ((symbol = getchar()) != '.') {
        if (symbol >= 'a' && symbol <= 'z') {
            printf("%c", (symbol - 'a' + N) % 26 + 'a');
        } else if (symbol >= 'A' && symbol <= 'Z') {
            printf("%c", (symbol - 'A' + N) % 26 + 'A');
        } else {
            printf("%c", symbol);
        }
    }

    printf(".\n");

    return 0;
}
